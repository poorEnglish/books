### 纯函数的好处
> 纯函数的概念：相同的输入永远得到相同的输出，而且，没有任何可观察的副作用

“作用”可以理解为一切除了结果计算之外的事。它本身没有什么坏处，“副作用”的关键部分在“副”，“副”是滋生bug的温床

副作用包含并不限于：
- 更改文件系统
- 向数据库插入数据
- 发送http请求
- 可变数据
- 打印/log
- 获取用户输入
- DOM查询
- 访问文件系统....

概括地说，只要和函数外部环境发生地交互都是副作用。

有了副作用的函数不能说是纯函数：函数和外部事物交互不能保证相同的输入返回相同的结果

#### 追求纯函数的理由

##### 可缓存性（Cacheable）
例如：
````
  var memoize = function(f) {
  var cache = {};

  return function() {
    var arg_str = JSON.stringify(arguments);
    cache[arg_str] = cache[arg_str] || f.apply(f, arguments);
    return cache[arg_str];
  };
};  
````
> 值得注意的是利用延迟执行的方式把不纯的函数转换称纯函数:
```` 
var pureHttpCall = memoize(function(url, params){
  return function() { return $.getJSON(url, params); }
});
````
上面这个函数叫纯函数只是因为输入相同的URL和params，返回同一个hrrp请求的函数，至于返回的这个函数是不是纯函数，那就是后边的事了。

##### 可移植性/自文档化（Portable / Self-Documenting）
纯函数完全自给自足，好处有很多：
- 依赖明确，易于观察和理解---没有偷偷摸摸的小动作
- 强迫“注入”依赖（明确写出需要的参数），应用也会更加灵活

##### 可测试性（Testable）
纯函数可以让测试更容易

##### 合理性（Reasonable）
引用透明性：
>如果一段代码在不改变程序行为的前提下，可以替换为它执行所得的结果，那么这段代码就是引用透明的

等式推导:
>等式推导意指“一一替换”，类似于在不考虑怪异模式的情况下，手动执行相关代码。

##### 并行代码
最重要的一点：因为纯函数不需要访问共享的内存，也不会因为副作用进入竞争态

