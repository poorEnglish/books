- 精确匹配
在正斜杠内的字符串表示精确匹配，需要每个都匹配才可以
- 匹配-类字符
若想匹配一个有限字符集，可以把字符集放在中括号内。[abcde]表示a到e的任意字符,[^abcde]表示非a到e任意字符
- 重复出现
    - 字符后加？：一次或没有
    - +：一次或多次
    - *：0次或多次
    - {number}: 精确的出现次数  
    - {number1,number2}: 大于等于number1的次数，且小于等于number2的次数
    - {number,}： 省略右边意为大于等于number1的次数
    这些操作默认是贪婪的：即会匹配所有的字符组合。在操作符后加上？可以使其变为非贪婪，只进行最小程度匹配
- 预定义字符(略)    
- 分组
小括号可以把正则分组，还可以创建捕获
- 或操作符
或操作符|表示或的关系 /(ab)+|(cd)+/
- 反向引用
反向引用有点意思啊，就像是把捕获的字符串作为了变量一样，可以在后边使用，此时引用不会按照引用的规则，而是会严格按照第一个捕获的字符串来匹配。常用于ml标签（xml，html）。
类似的`/<(\w+)>(.+)<\/\1>/` 后边的\1就严格匹配第一个捕获的标签名称


#####编译正则
- js引擎把编译表达式，转成内部表示
- 每个正则表达式都有一个独立的对象表示，每次创建正则都创建一个新的对象，同其他原始类型不同，其结果独一无二
-  RegExp() 构造器一般用来动态创建正则

#####捕获匹配的片段
- 简单的捕获
```js
let str="fdsfstestfgd";
str.match(/\w+tes(\w+)/);//也可以用exec
/*{
*  0:"fdsfstestfgd",
*  1:"tfgd",
*  groups:undefined
*  index:0,
*  input:"fdsfstestfgd"
*  }
/
```
*捕获是由正则的小括号(因子)定义的*
match如果匹配的话，返回值的第一项是完整的匹配值，然后是每个后续捕获的结果。
- 全局捕获
不给正则加标记g，match只会默认返回第一个匹配的字段，但在加上g标记后，会进行全局匹配，返回匹配结果的列表
RegExp.exec()，如果是g标记的，会保存上一次的状态，往后匹配，知道无法匹配返回null，再循环
- 捕获的引用
    - \1 \2
    - replace(/reg/,$1):  \$1 \$2

- 不捕获的分组

